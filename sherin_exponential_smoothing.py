# -*- coding: utf-8 -*-
"""Sherin - Exponential smoothing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DA_OMLxag_1VZ1bvOvcByFAOQF-RjNSL
"""

#first order exponential smoothing
import numpy as np
import matplotlib.pyplot as plt

def exponential_smoothing_first_order(y, lam, y0):
  smoothed = [y0]
  for t in range(1, len(y)):
    s_t = y[t]*lam + (1-lam)*smoothed[-1]
    smoothed.append(s_t)

  return smoothed


#main
periods = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
yt = np.array([np.random.uniform(0, 1) for _ in range(10)])
y_mean = np.mean(yt)

for i in range(10):
  lam = np.random.uniform(0,1)
  smoothed_1 = exponential_smoothing_first_order(yt , lam, y_mean )
  smoothed_2 = exponential_smoothing_first_order(yt , lam, yt[0] )
  plt.figure(figsize = (10,10))
  plt.plot(yt, 'ro', color='black', linestyle='-', label="Actual data")
  plt.plot(smoothed_1, 'ro', color='red', linestyle='-', label = "y0 = mean")
  plt.plot(smoothed_2, 'ro', color='blue', linestyle='-',label = "y0 = yt_0")
  plt.legend()
  plt.grid(True)
  plt.title(f"First order Exponential smoothing with lam ={lam}")
  plt.show()
  print("\n")

#ttest (between the actual and the smoothed data) -> without inbuilt function
import math
from scipy.stats import t

lam = np.random.uniform(0,1)
smoothed = exponential_smoothing_first_order(yt , lam, y_mean )
before = yt
after = smoothed

d = before - after
d_mean = np.mean(d)

d_std = np.std(d, ddof = 1 )
n = len(d)

t_stat = d_mean / (d_std/math.sqrt(n))
p_val = 2 * t.sf(abs(t_stat), df=n-1)
alpha = 0.05

print(before)
print(after)
print(f"\n\nt-statistic = {t_stat}")
print(f"\np-val= {p_val}\n")

#Null hypothesis -> no sigificant difference between before and after
if p_val < alpha:
  print("Reject null hypothesis -> Significant difference between before and after")
else:
  print("Do not reject null hypothesis -> No Significant difference between before and after ")

#Second order exponential smoothing

def exponential_smoothing_second_order(y, lam):
  n = len(y)
  y1 = np.zeros(n)
  y2 = np.zeros(n)
  y_hat = np.zeros(n)

  y1[0] = y[0]
  y2[0] = y1[0]
  y_hat[0] = y[0]

  for t in range(1, n):
    y1[t] = lam*y[t] + (1-lam)*y1[t-1]
    y2[t] = lam*y1[t] + (1-lam)*y2[t-1]
    y_hat[t] = 2*y1[t] - y2[t]

  return y1, y2, y_hat

#main

yt = np.array([
    48.7, 45.8, 46.4, 46.2, 44.0,
    53.8, 47.6, 47.0, 47.6, 51.1,
    49.1, 46.7, 47.8, 45.8, 45.5,
    49.2, 54.8, 44.7, 51.1, 47.3,
    45.3, 43.3, 44.6, 47.1, 53.4,
    44.9, 50.5, 48.1, 45.4, 51.6,
    50.8, 46.4, 52.3, 50.5, 53.4,
    53.9, 52.3, 53.0, 48.6, 52.4,
    47.9, 49.5, 44.0, 53.8, 52.5,
    52.0, 50.6, 48.7, 51.4, 47.7
], dtype=float)

lam = 0.3
train_n = 35
y_train = yt[:train_n]
y_test = yt[train_n:]
periods = np.arange(1, len(yt) + 1)

y1, y2, y_hat = exponential_smoothing_second_order(y_train, lam)

#testing
# Compute a_T (level) and b_T (trend) at last training point

y1_T = y1[-1]
y2_T = y2[-1]

a_T = 2*y1_T  - y2_T
b_T = (lam/(1-lam)) * (y1_T - y2_T)


print(f"a_T = {a_T}")
print(f"b_T = {b_T}")

test_pred = []

h_steps = np.arange(1, len(y_test)+1)
for h in h_steps:
  test_pred.append(a_T + (b_T*h))

test_pred = np.array(test_pred)
print(test_pred)



#visualization:
print("\n\n")
plt.figure(figsize=(10,10))
plt.plot(periods[:train_n], y_train, label="Actual data", marker='o', color='black', linestyle='-' )
plt.plot(periods[:train_n], y1, label="First smoother", marker='o', color='red', linestyle='--' )
plt.plot(periods[:train_n], y2, label="Second smoother", marker='o', color='blue', linestyle='--' )
plt.plot(periods[:train_n], y_hat, label="Fitted data - y_hat", marker='o', color='purple', linestyle='--' )
plt.title("Second order exponential smoothing")
plt.legend()
plt.grid(True)
plt.show()




print("\n\n")
plt.figure(figsize=(10,10))
plt.plot(periods[train_n:], y_test, label="Actual test data", marker='o', color='black', linestyle='-' )
plt.plot(periods[train_n:], test_pred, label="Predicted test data", marker='o', color='red', linestyle='--' )
plt.title("Test results")
plt.legend()
plt.grid(True)
plt.show()